# 面试要点

## 自我介绍

简洁，点出重点，引导提问项目 1 ～ 3 分钟

## 项目介绍

提出项目亮点，使用的技术栈。以及对整个项目技术层面的了解。
白屏时间，实现各种功能的项目。
怎么优化，提高团队项目

## 面试过程

- 前端基础 this, 网络, 事件循环, 写一些简单的逻辑代码
- 算法，大概率一道中等算法，尽量留一道算法题的时间。(分数占比不高)
- 有一个自己比较精通的领域，知识点。(Docker, Canvas, node, 性能优化，工程化)

## 平时准备

- 尝试找一个觉得有亮点的项目，在公司或者社区中推动
- 开始前进行技术选型，并清楚这么做的目的
- 进行中的时候及时记录遇到的困难，积极寻找解决方案
- 结束的时候进行整理，总结整个项目带来的成长和收获

## 具体面试题

### 网络和并发

#### HTTP/1.0/1.1/2.0 在并发请求上主要的区别是什么？

1. HTTP 1.0
   每个 TCP 连接只能发送一个请求，当服务器响应后就会关闭这个连接，下一个请求建立新的 TCP 连接
   每个请求只能发一个请求。这个连接是指 HTTP 连接还是 TCP 连接？ TCP 连接
   Connection: keep-alive 可以启用持久连接
2. HTTP 1.1
   默认采用持久连接，TCP 连接
   Connection: close 可以关闭持久连接
   添加管道机制, 在同一个 TCP 连接里，允许多个请求同时发送。是一问一答的形式。
   因为 TCP 所有的数据通信都是有顺序的，因此为了保持数据的顺序和正确性，可能会导致队头拥塞。
3. HTTP 2.0
   添加双工模式，客户端和服务端可以同时处理多个请求。解决了队头阻塞的问题。
   添加多路复用技术，没有次序概念。
   增加了服务端推送功能，服务端可以主动发起请求。

#### HTTP 1.1 的长连接和 HTTP 2.0 的多路复用有什么区别

1.1: 同一时间同一个 TCP 连接只能处理一个请求，采用一问一答的形式。上一个请求响应后才能处理下一个请求。
Chrome 最多支持 6 个并发请求，这是怎么回事？Chrome 允许同时发起 6 个 TCP 连接

2.0: 同域名上的所有通信都在单个连接完成。消除了需要建立多个 TCP 连接的性能损耗。单个连接上可以并行交错的进行请求和响应

#### HTTP 1.1 为什么不能实现多路复用？

HTTP 2.0 传输的数据是基于二进制帧进行传输，而 HTTP 1.1 是基于文本解析的协议
1.1 的报文结构里，服务器需要不断的读入字节，直到遇到换行符，所以处理的顺序必须是串行的。

2.0 的报文结构里以帧为最小数据单位，每个帧都会有标识自己属于哪个流，多个帧组成一个流。

多路复用其实就是一个 TCP 连接里同时存在多个流。

#### 前端代码里怎么控制最大并发量？

- 基于 Promise 实现一个代码方案，支持限制并发量，控制最大并发量进行传输，可选项可以加入优先级参数

### 内存处理

#### 关注过内存处理吗？简述 js 中的内存管理，什么时候会导致内存泄露呢？

内存分配: 声明变量 函数 对象的时候
内存使用: 读写内存 使用变量 函数等
内存回收: 使用完毕，由垃圾回收机制自动回收不再使用的内存

js 中的内存回收机制

- 引用计数法
  看一个对象是否有指向它的引用，如果没有其他对象指向它，则说明此对象不需要了，应该清除
  循环引用问题，导致内存泄漏
- 标记清除法
  将不再使用的对象定义为无法达到的对象
  检测的时候从 js 的全局对象触发，定时扫描内存中的对象，凡是无法到达的对象则标记为需要清除，稍后等候回收

  垃圾收集器在运行的时候会给存储在内存中的所有变量对加上标记
  将从根部触发能够触及到的对象标记清除
  剩下的还有标记的变量视为准备清除的变量
  垃圾收集器销毁所有带有标记的变量，销毁空间

常见的内存泄漏

1. 全局变量
2. 未被清理的定时器和回调函数
3. 闭包
4. DOM 引用

怎么避免内存泄漏

1. 避免使用全局变量
2. 使用完数据后及时解除变量
3. 注意闭包的使用
4. 避免死循环或者持续执行的操作

#### 实现一个 sizeof 函数

接受一个对象参数，计算传入的对象所占的字节数。

1. string 类型每个长度占 2 个字节
2. boolean 类型占 4 个字节
3. number 占 8 个字节
4. 数组类型占用的空间为数组元素占用的空间之和
5. 对象类型 (null 占 0 字节)
   需要对对象的值进行去重，相同的引用不再重复计算。
   对象类型的总量需要同时加上 key, value 的值
